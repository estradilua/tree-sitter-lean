======
syntax
======

syntax "=>" term:2 : term

---

(module
  (command
    (syntax
      (syntax_p
        (atom
          (str_lit)))
      (syntax_p
        (cat
          (ident)
          (precedence
            (num_lit))))
      (ident))))

====================
initialize ambiguous
====================

initialize foo : Int ← pure ()
                       return 2

---

(module
  (command
    (initialize
      (ident)
      (type_spec
        (term
          (ident)))
      (left_arrow)
      (do_seq
        (do_seq_indent
          (do_seq_item
            (do_elem
              (do_expr
                (term
                  (ident)))))
          (do_seq_item
            (do_elem
              (do_expr
                (term
                  (ident)
                  (literal
                    (num_lit)))))))))))

=================
initialize do_seq
=================

initialize let foo : Int ← pure ()
           return 2

---

(module
  (command
    (initialize
      (do_seq
        (do_seq_indent
          (do_seq_item
            (do_elem
              (do_let_arrow
                (do_id_decl
                  (ident)
                  (type_spec
                    (term
                      (ident)))
                  (left_arrow)
                  (do_elem
                    (do_expr
                      (term
                        (ident))))))))
          (do_seq_item
            (do_elem
              (do_expr
                (term
                  (ident)
                  (literal
                    (num_lit)))))))))))

===================================
nested do_seq blocks ending at once
===================================

initialize
  do
    let a := 1

---

(module
  (command
    (initialize
      (do_seq
        (do_seq_indent
          (do_seq_item
            (do_elem
              (do_nested
                (do_seq
                  (do_seq_indent
                    (do_seq_item
                      (do_elem
                        (do_let
                          (let_decl
                            (let_pat_decl
                              (term)
                              (defeq)
                              (term
                                (literal
                                  (num_lit))))))))))))))))))

================
inductive vacant
================


inductive Vacant : Type where

---

(module
  (command
    (declaration
      (inductive
        (decl_ident
          (ident))
        (type_spec
          (term
            (ident)))))))

==================
inductive either''
==================

inductive Either'' : Type u → Type v → Type (max u v + 1) where
  | left : {α : Type u} → {β : Type v} → α → Either'' α β
  | right : β → Either'' α β

---

(module
  (command
    (declaration
      (inductive
        (decl_ident
          (ident))
        (type_spec
          (term
            (ident)
            (ident)
            (ident)
            (term
              (ident)
              (literal
                (num_lit)))))
        (ctor
          (ident)
          (type_spec
            (term
              (term
                (ident))
              (term
                (ident))
              (ident))))
        (ctor
          (ident)
          (type_spec
            (term
              (ident))))))))

==========================
definition with match_alts
==========================

def AtLeastOne.head : AtLeastOne α → α
  | ⟨x, _⟩ => x
  | .mk x _ => x

---

(module
  (command
    (declaration
      (definition
        (decl_ident
          (ident
            (ident)))
        (type_spec
          (term
            (ident)))
        (decl_val
          (decl_val_eqns
            (match_alts
              (match_alt
                (term
                  (term))
                (darrow)
                (term))
              (match_alt
                (term
                  (ident))
                (darrow)
                (term)))))))))
